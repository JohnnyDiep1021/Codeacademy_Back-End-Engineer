Traversing a Binary Tree
There are two main ways of traversing a binary tree: breadth-first and depth-first. With breadth-first traversal, we begin traversing at the top of the tree’s root node, displaying its data and continuing the process with the left child node and the right child node. Descend a level and repeat this step until we finish displaying all the child nodes at the deepest level from left to right.

With depth-first traversal, we always traverse down each left-side branch of a tree fully before proceeding down the right branch. However, there are three traversal options:

Preorder is when we perform an action on the current node first, followed by its left child node and its right child node
Inorder is when we perform an action on the left child node first, followed by the current node and the right child node
Postorder is when we perform an action on the left child node first, followed by the right child node and then the current node
For this lesson, we will implement the inorder option. The advantage of this option is that the data is displayed in a sorted order from the smallest to the biggest.

To illustrate, let’s say we have a binary tree that looks like this:

           15
     /------+-----\
    12            20
   /   \         /   \   
 10     13     18     22
 / \   /  \    / \   /  \
8  11 12  14  16 19 21  25
We begin by traversing the left subtree at each level, which brings us to 8, 10 and 11 reside. The inorder traversal would be:

8, 10, 11
We ascend one level up to visit root node 12 before we descend back to the bottom where the right subtree of 12, 13, and 14 resides. Inorder traversal continues with:

12, 12, 13, 14
We again ascend one level up to visit root node 15 before we traverse the right subtree starting at the bottom level again. We continue with the bottom leftmost subtree where 16, 18 and 19 reside. The inorder traversal continues with:

15, 16, 18, 19
We ascend one level up to visit root node 20 before we descend back to the bottom where the rightmost subtree of 21, 22 and 25 resides.

Traversal finishes with:

20, 21, 22, 25
The entire traversal becomes:

8, 10, 11, 12, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 25
Notice that all the values displayed are sorted in ascending order.

Which of these is NOT true about our JavaScript binary tree implementation?
=>  The height of a binary tree can be determined from the top node's depth because the depth of the top root node is always 1, and doesn’t determine the height of the tree.

Which of these depth-traversal methods returns a sorted data list in a binary tree?
=> Inorder

REVIEW
In this lesson, you have successfully built a binary tree data structure in JavaScript. You have implemented:

a BinaryTree class containing value, left and right child nodes and a depth
an .insert() method to add and place a value at the correct location in the binary tree
a .getNodeByValue() method to retrieve a child node by its value or null
a .depthFirstTraversal() method to traverse the binary tree using the inorder traversal option

Use your solid understanding of binary search to explore more in-depth materials or even try some code challenges. These recommendations are optional but will help you hone your skills to become more prepared for the technical interview!

Additional Resources:

Interactive: Searching Sorted List
https://www.cs.usfca.edu/~galles/visualization/Search.html

Interactive: Binary Search Tree
https://visualgo.net/en/bst?slide=1

Code Challenges:

Beginner - Binary Search
https://leetcode.com/problems/binary-search/

Beginner - Search Insert Position
https://leetcode.com/problems/search-insert-position/

Beginner - Convert Sorted Array to Bnary Search Tree
https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/

Beginner - Find Mode in Binary Search Tree
https://leetcode.com/problems/find-mode-in-binary-search-tree/